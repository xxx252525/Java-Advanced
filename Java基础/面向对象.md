# 类与对象

物以类聚，什么是类？我们知道我们常见的物品都是分类的，根据不同的特征进行分类，把一些相同特征的物品氛围一个类别，在编程中，类也是这个道理。把共有的特点作为物品的属性，这就是类。而包含这写类属性的物品我们叫他对象。

以下这段代码就表示了一个简单的类。

- class是类的关键字，表明这是一个类，class前面会有一个修饰符来表明这个类的使用范围【一般叫也做作用域】，比如public就表示共有的，对大家都可以使用；
- cat表示一个类的名字，也就是猫类；
- {}内的是属性，也就是猫的特点；

> **注意：后续文章中代码中出现“# xxx.java”的字样表示这个代码的类文件名，不是代码的一部分，请注意辨别！！！**

```java
# 类
class cat {
    String name;
    int age;
    String color;
}
```

以下的代码表示对象：

- 在代码中我们使用Cat类创建了一个对象实例Cat()，并将其赋值给变量cat；
- 使用cat.name调用Cat类的属性name，并给他赋值，于是有了猫的名字“Tom”；

```java
# 对象

public class class24090901 {

    public static void main(String[] args) {
        //创建对象
        Cat cat = new Cat();
        cat.name = "Tom";
        cat.age = 5;
        cat.color = "white";
        System.out.println(cat.name + " " + cat.age + " " + cat.color);

        Cat cat2 = new Cat();
        cat2.name = "Jerry";
        cat2.age = 6;
        cat2.color = "black";
        System.out.println(cat2.name + " " + cat2.age + " " + cat2.color);

    }
}
```

## 方法的定义和调用

定义方法的格式如下：

```java
修饰符 方法的返回值类型 方法名(形参列表){
    方法主体
    和返回值
}
```

- 调用方法也是非常简单的，当创建实例之后，只需要用实例引用方法即可：

```java
实例.方法()
```

```java
# 方法的定义和调用
import java.time.LocalDate;
import java.util.Scanner;

public class CountAge {
    //创建属性
    public int age;
    public int year;

    //创建方法
    public void count() {
        //接收年龄
        System.out.println("请输入你的年龄");
        Scanner sc = new Scanner(System.in);
        age = sc.nextInt();
        //自动获取当前年份
        LocalDate localDate = LocalDate.now();
        int year = localDate.getYear();
        System.out.println(year);
        //计算出生年份
        int YearOfBirth = year - age;
        System.out.println("出生年份为：" + YearOfBirth);
    }

    public static void main(String[] args) {
        //创建对象
        CountAge countAge = new CountAge();
        //调用方法
        countAge.count();
    }
}

```

## 传递参数

一个方法可以有多个参数，也可以没有参数，多个参数的时候用逗号隔离；参数可以为任意类型；在方法定义的时候的参数叫做形式参数（简称形参），方法实际调用的参数叫做实际参数（简称实参）；实参和形参的类型、数量、顺序必须一致。

在count方法中传递参数，设置传递参数的类型和变量，在调用函数的时候传入对应的类型的值即可，例如：

```java
# 传递参数
import java.util.Scanner;

public class CountAge {
    //创建属性
    public int age;
    public int year;

    //创建方法
    public void count(int year) {
        //接收年龄
        System.out.println("请输入你的年龄");
        Scanner sc = new Scanner(System.in);
        age = sc.nextInt();
        
        //计算出生年份
        int YearOfBirth = year - age;
        System.out.println("出生年份为：" + YearOfBirth);
    }

    public static void main(String[] args) {
        //创建对象
        CountAge countAge = new CountAge();
        //调用方法
        countAge.count(2024);
    }
}
```

这里给定了一个int类型的形参year，我们在调用方法的时候传入形参的值为2024。

### 方法的传参机制

值传递时，传递的是实参的副本，形参的修改不会影响实参

<img src="./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240911210859705.png" alt="image-20240911210859705" style="zoom:;" />

---

引用传递时，传递的是实参的引用（地址），形参的修改可能会影响实参

```java
 public class ReferenceTransfer {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        modifyArray(arr);
        System.out.println(arr[0]);  // 输出 10
    }

    public static void modifyArray(int[] array) {
        array[0] = 10;  // 修改数组的第一个元素
    }
}

```

`arr` 是一个引用类型的数组，传递给 `modifyArray()` 时，传递的是数组的引用（地址）。在 `modifyArray()` 函数中，通过这个引用修改了数组的第一个元素，把 `array[0]` 改为 10。因为 `arr` 和 `array` 实际上指向同一个数组，所以修改 `array` 的内容也会影响 `arr`，所以最终在 `main()` 函数中输出的 `arr[0]` 的值为 10。

---

在Java等编程语言中，`String`类型的参数传递有一些特殊之处，`String`在Java中是不可变的（immutable），也就是说，一旦创建了`String`对象，不能更改它的内容。每次对`String`进行修改时，都会生成一个新的`String`对象，而原始的`String`对象保持不变。例如：

```java
public class StringTest {
    public static void main(String[] args) {
        String str = "Hello";
        modifyString(str);
        System.out.println(str);  // 输出还是 "Hello"
    }

    public static void modifyString(String s) {
        s = s + " World";
        System.out.println(s);    // 输出 "Hello World"
    }
}

```

`str` 传递给了 `modifyString()` 方法，实际上传递的是`str`引用的副本。在`modifyString()`方法内部，当执行 `s = s + " World"` 时，实际上创建了一个新的`String`对象 `"Hello World"`，并将`s`的引用指向这个新对象。但是原始的`str`仍然指向最初的 `"Hello"`，因此`main()` 方法中的 `str` 没有受到影响。

---

## 内外部调用

内外部调用就是在类的内部和外部调用的区别，请看代码：

```java
# 内部低调用方法
import java.time.LocalDate;
import java.util.Scanner;

public class CountAge {
    //创建属性
    public int age;
    public int year;

    //创建方法
    public void count(int year) {
        //接收年龄
        System.out.println("请输入你的年龄");
        Scanner sc = new Scanner(System.in);
        age = sc.nextInt();
        
        //计算出生年份
        int YearOfBirth = year - age;
        System.out.println("出生年份为：" + YearOfBirth);
    }

    public static void main(String[] args) {
        //创建对象
        CountAge countAge = new CountAge();
        //调用方法
        countAge.count(2024);
    }
}

```

我们创建好了类为CountAge()，在类的里面定义了属性、方法和Main主体方法；在一个雷总进行方法调用就叫做内部调用，如果不在一个类中，在另外一个A类中调用B类方法和属性，这就叫做外部调用，如下：

```java
# Cat.java

//定义类
public class Cat {
    //定义属性
    String name;
    int age;
    String color;

    //定义方法
    void eat(){
        System.out.println("吃鱼");
    }
    void drink(){
        System.out.println("喝水");
    }
    void sleep(){
        System.out.println("睡觉");
    }

}
```

```java
# CatHabit.java

public class CatHabit {

    public static void main(String[] args) {
        //实例化对象
        Cat cat = new Cat();
        //调用方法
        cat.drink();
        cat.eat();
        cat.sleep();
    }
}
```

可以看见这是两个Java文件，我们在CatHabit这个类中调用了Cat.java文件中的Cat类的方法，从而实现外部调用，外部调用会被方法本身的修饰符限制，在使用的时候请注意。

## 返回值

一个方法只能返回一个值，然后返回多个可用数组，返回值可以是任何类型，但是必须和return的值类型兼容，没有就可以使用viod表示。

```java
# Cat.java

//定义类
public class Cat {
    //定义属性
    String name;
    int age;
    String color;
    
    //返回值
    int[] num(){
        System.out.println("返回值：");
        return new int[] {100,200,300,400,500};
    }

}
```

这里在Cat.java文件中创建了一个方法num用来返回一个数组的信息，然后我们在CatHabit.java调用num的方法并且将其赋值给数组a，然后遍历打印出数组的信息，在`int[] a = cat.num()`中队的数组实际上是这样的`int[] a = {100,200,300,400,500]`，所以当我们遍历打印的，实际上是Cat.java类中num返回的数组。

```java
# CatHabit.java
public class CatHabit {

    public static void main(String[] args) {
        //调用方法
        int[] a = cat.num();
        for (int i : a) {
            System.out.println("array:" + i);
        }
        System.out.println(Arrays.toString(a));
    }
}
```

方法嵌套的时候执行顺序就是代码写的顺序。

当执行方法的时候，会开辟一个独立的栈空间，然后当方法执行完毕后会返回到方法调用的地方，然后继续执行后面的代码，直到执行完毕`main`方法。

<img src="./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240911205034692.png" alt="image-20240911205034692" />

## 静态属性Static

静态属性也叫做类属性，与之对应的还有实例属性，也叫做对象属性。

```java
# CodeEdit.java
public class CodeEdit {
    //实例属性
    String Tools;
    String CodeLanguage;
    //静态属性
    static String CodeEditor;

    //实例方法
    public void StudyCodeLanguage(){
        Scanner str = new Scanner(System.in);
        System.out.println("请输入你学习编程语言");
        CodeLanguage = str.nextLine();
        System.out.println("你学习编程语言是"+CodeLanguage);

    }
    //静态方法
    public static void UseCodeEditor(){
        Scanner str = new Scanner(System.in);
        System.out.println("请输入你使用的编程编辑器");
        CodeEditor = str.nextLine();
        System.out.println("你使用的编程编辑器是"+CodeEditor);
    }

}
```

可以明显看出两者的区别，实例属性和方法必须创建一个实例，然后调用其方法；而静态属性就很方便，可以直接通过类进行方法和属性的调用，不需要像实例属性和方法一样，重复创建实例进行调用。

```java
# Test03.java
public class Test03 {

    public static void main(String[] args) {
        CodeEdit x = new CodeEdit();
        //调用实例属性
        x.Tools = "Minecraft Launcher";
        x.CodeLanguage = "Java";
        //调用实例方法
        x.StudyCodeLanguage();
        //调用静态属性
        CodeEdit.CodeEditor = "IDEA";
        //调用静态方法
        CodeEdit.UseCodeEditor();
    }
}
```

## Java重载

在同一作用域内，允许我们使用同一个方法名来执行不同的操作，比如传递参数的时候不限制类型、数量、顺序等，与返回值无关，只看参数列表，这就是重载，重载是一种多态性表现形式。

例如：

```java
import java.util.Arrays;

public class Test04 {
    //定义方法
    static String test(String str) {
        return str;
    }

    static int test(int a) {
        return a;
    }

    static int[] test(int[] arr) {
        return arr;
    }

    static double test(double d) {
        return d;
    }

    static boolean test(boolean b) {
        return b;
    }

    static float test(float f) {
        return f;
    }

    static char test(char c) {
        return c;
    }

    public static void main(String[] args) {
        //调用方法
        String str = test("Hello");
        int a = test(100);
        int[] arr = test(new int[]{1, 2, 3});
        double d = test(3.14);
        boolean b = test(true);
        float f = test(3.14f);
        char c = test('A');
        System.out.println(str + " " + a + " " + Arrays.toString(arr) + " " + d + " " + b + " " + f + " " + c);
    }
}

```

可以看见，我们在定义test方法的时候使用了不同类型的数据类型进行大量的定义，如果是相同的就会出现错误，然后我们在调用传入参数的时候就可以传入自己定义过的任意类型。

## 可变参数

让方法接受任意参数，这就是可变参数，只需要在参数类型后面添加`...`即可。

可变参数可以当做数组处理、本质上也是一个数组；可变参数的实参可以为数组，数量为任意；注意只能传入一种类型，传入任意数量的时候，不能同时传入多种类型。

例如：

```java
public class Test05 {

    public static void main(String[] args) {
        System.out.println(test(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        System.out.println(test("Hello", "World"));
    }

    //可变参数
    static int test(int... arr) {
        return 0;
    }

    static String test(String... arr) {
        return "";
    }
}
```

可以看见，我们在定义方法的的时候在数据类型后面添加了`...`，当传入大量参数的时候必须是同一个数据类型，如果是不同类型就会报错。

## 构造器

构造器和类名是一样的，没有返回值；当创建对象的时候会自动调用构造器；如果没有构造器就会自动生成一个默认的无参数的构造器。

一个类可以定义多个不同的构造器，也就是构造器的重载；当构造器被定义之后，默认的构造器就被覆盖了。

```java
#Test.java

public class Test {
    String name = null;
    //创建构造器
    Test(){
        System.out.println("Test()");

    }

    Test(String Name){
        System.out.println("Test(String Name)");
    }

    Test(String Name, int num){
        System.out.println("Test(String Name, int num)");
    }
}

```

可以看见我们创建了多个构造器，每个构造器的参数不一样；我们通过创建实例的方式来调用方法，运行之后会就输出构造器的返回结果。

```java
# Test06.java

public class Test06 {

    public static void main(String[] args) {
        Test test = new Test();
        Test test1 = new Test("Hello");
        Test test2 = new Test("Hello",100);

    }

}
```

在创建对象的过程中，加载类的信息只会加载一次、然后在堆里面分配地址，然后完成对象的初始化（从默认初始化到显示初始化，最后到构造器初始化）。

## 变量作用域

### 全局变量

全局变量就是除了在自己的类中调用，还可以在其他的类里面调用，可以添加访问修饰符号，可以不用赋值直接使用，有默认值。

例如：

```java
# Test.java
package objectOriented;

public class Test {
    //全局变量
    public static int count = 0;                //全局静态变量int
    public String name;							//全局变量name

    public void test (){						//公有的方法
        count = 100;
        name = "天阁创客official";
        System.out.println("在当前的Test类中调用变量count和name");
    }
}
```

```java
# Test06.java
package objectOriented;

public class Test06 {

    public static void main(String[] args) {

        //在另外一个类中调用Test的全局变量
        Test test = new Test();
        test.name = "tiangesec.org.cn";
        test.test();
        System.out.println("在Test06类中调用Test的name变量和方法");

    }

}
```

可以看见我们在Test类中和Test06中都调用了Test的属性和方法，这就是全局变量。运行结果如下：

![image-20240916155650230](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916155650230.png)

**注意：全局变量当创建的对象被销毁的时候就会被销毁，被创建的时候也会伴随对象而创建。一般在类中定义的变量没有加特殊的修饰符就可以被全局调用，作用域会受到修饰符号的影响**

### 局部变量

属性在之外的地方无法调用，只能在当前的作用与中调用，只能在对应的代码块中使用。局部变量没有默认值，必须赋值之后才能使用，随着代码的结束就会被销毁，并且不可以加访问修饰符号。

如图：

![image-20240916160631446](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916160631446.png)

![image-20240916160943585](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916160943585.png)

**全局变量与局部变量的对比：**

![image-20240916161246970](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916161246970.png)

### 块级作用域

块级别作用句就是在某个代码块，某个片段中被定义，仅能被当前片段而调用的变量。在全局中有全局块作用域，在局部中有局部作用域，例如：

#### 静态块变量

![image-20240916162952436](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916162952436.png)

#### for循环块变量

想类似与for循环这样类似的块区域类型的语句，创建出的代码块中的变量是只能在当前区域类型的语句块中调用入，如图：

![image-20240916163654443](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916163654443.png)

还有其他的例子我这里就不一一举例了。

## this

在Java虚拟机中会给每一个对象分配this，代表当前对象。this用于区分当前对象的属性和局部变量，以为this不能在类的外部使用，只能在类的内部方法中使用，用于类的内部赋值和获取实例的属性。

```java
# Test.java
package objectOriented;

public class Test {
    public String name;
    public int age;

    public  Test (){
        System.out.println("Test()"+ this.hashCode());
    }

    public Test(String name){
        this.name = name;
        System.out.println("this1:" + this.hashCode());
    }

    public Test(String name, int age){
        this.name = name;
        System.out.println("test2::" + this.hashCode());
    }
}
```

```java
# Test06.java
package objectOriented;

public class Test06 {

    public static void main(String[] args) {

        //创建对象
        Test a = new Test();
        Test c = new Test("Hello");
        Test d = new Test("World", 100);

        System.out.println("a:" + a.hashCode());
        System.out.println("================");
        System.out.println("c:" + c.hashCode());
        System.out.println("================");
        System.out.println("d:" + d.hashCode());

    }
}
```

运行结果如下：

![image-20240917164447432](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240917164447432.png)

当创建新的实例的时候会调用到那个方法，但是那个方法已经开辟了一个空间存放了一个地址了，这个地址就会被赋值给实例。也就是说哪一个对象调用这个方法，那么这个this就会指向哪一个对象。

## 包

包是用来区分相同名字的类的，同时当类非常多的时候可以用来管理这些类，控制类的访问范围。

例如我前面几个代码，前面都有几个类似的字符串：`package objectOriented`，这就是一个包，在Java里面叫做包，实际上和文件夹、目录是一样的东西，就是一个目录，用来存放这个相似功能的类文件。

### 创建包

创建包就是创建一个目录，例如在当前的工作目录里面创建新的目录名叫``StudyJava`，可以看见创建包就只是一个目录，在IDEA里面点击创建的时候是叫做package如图：

<img src="./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240917170517339.png" alt="image-20240917170517339"  />

<img src="./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240917170147448.png" alt="image-20240917170147448"  />

可以看见包的内部没有其他文件，只有几个创建好的Java类文件，Java不像某些编程语言的包里面会生成一些文件（这样子就很容易区分包和目录）。

![image-20240917170339567](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240917170339567.png)

**注意：创建包名字的时候要注意命名的规则和创建变量名的规则是相同的。**

### 打包

`package objectOriented;`就叫做打包，这行语句是放在最上面的。

![image-20240917171014705](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240917171014705.png)

### 导包

什么是导包？在代码中使用``import`关键字进行导入一个包，这个操作就是导包，例如：

![image-20240917171301776](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240917171301776.png)

这里显示了如何导入一个包，我们将Java里面的`util`包中的Scanner的包导入了进来，我们就可以停过Scanner的包来调用里面的类。

## Java访问修饰符

访问修饰符号就是用来控制属性和方法、类的使用范围，例如前面常常看到的`public`，这就是其中的一个修饰符的关键字，表示公共的，都可以使用。还有其他几个修饰符，这是他们的作用范围：

| 名称      | 本类&#x1F600; | 同包&#x1F600; | 子类&#x1F600; | 不同包&#x1F600; |
| --------- | ------------- | ------------- | ------------- | --------------- |
| public    | ✓             | ✓             | ✓             | ✓               |
| protected | ✓             | ✓             | ✓             | ×               |
| 无        | ✓             | ✓             | ×             | ×               |
| private   | ✓             | ×             | ×             | ×               |

### 同包

例如：

```java
# Test06.java
package objectOriented;

public class Test06 {

    public static void main(String[] args) {
        Test test = new Test();
        test.a = 1;
        test.b = 1;
        test.c = 1;
        test.d = 1;				//无法被调用，报错
        test.test();
        test.test2();
        test.test3();			//无法被调用，报错
        test.test4();
    }

}
```

![image-20240917174519373](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240917174519373.png)

![image-20240917174833425](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240917174833425.png)

### 不同包

当我们在不同的包中调用不同属性和方法的情况如下：

![image-20240917175655893](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240917175655893.png)

可以看见，除了`public`以外，其他的访问修饰符定义的属性和方法都无法被其他包内的类访问。

## 封装

封装主要是用来提高代码的安全性的一种手段。主要就是实现数据的隐藏、防止外部的类直接访问和修改对象的内部数据，从而提高代码的安全性和可维护性。

### Java 中的封装实现

使用`private`来将属性和方法设置为私有，限制外部的访问权限，然后使用`public`的`getter()`和`setter()`方法来访问和修改私有属性。

例如以下代码：

```java
# Test.java
package objectOriented;

public class Test {
    private String name = null;
    //创建私有属性
    private String str;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if(name.length() > 6){
            System.out.println("名字太长了");
        }
        this.name = name;
    }

    public String getStr() {
        return str;
    }

    public void setStr(String str) {
        if (str.length() < 8) {
            System.out.println("密码不能少于8位");
        }
        this.str = str;
    }
}
```

我们在Test.java中创建了两个私有的属性，并且通过getName和setName的方式进行访问，可以看见get和set是需要同时出现的，不然就只能获取，没有办法传递参数。

当使用get的时候，我们需要返回get的参数，然后使用set进行参数的写入，这样才能实现对私有属性和方法的读写操作。

```java
# No1.java
package NewTest;

import objectOriented.Cat;
import objectOriented.Test;

public class No01 {
    public static void main(String[] args) {
        Test test = new Test();
        //使用getName获取值
        System.out.println(test.getName());
        System.out.println(test.getStr());

        //使用setName进行赋值
        test.setName("天阁创客official");
        test.setStr("123456");

        //输出新传入的值
        System.out.println(test.getName());
        System.out.println(test.getStr());

    }
}
```

![image-20240918152959149](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240918152959149.png)

#### 练习

定义Account类，要求具有属性: 姓名name (长度为2-4，初始化后不可修改)、余额balance(必须大于20)、密码password(必须是六位)。如果不满足，则给出提示信息，并给默认值(自己定)

```java
# Account.java
package practice01;

public class Account {
    private String name = null;
    private String password = null;
    private double balance = 0;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        //名字的长度为2-4，初始化后不可修改
        if(name == null) {
            System.out.println("名字不能为空");
            return;
        }
        if(this.name != null) {
            System.out.println("名字无法修改");
        }
        else {
            if (name.length() < 2 || name.length() > 4) {
                System.out.println("名字长度不符合要求");
            } else {
                this.name = name;
            }
        }

    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        if(password == null) {
            System.out.println("密码不能为空");
            return;
        }
        //密码必修为6位
        if (password.length() == 6) {
            this.password = password;
        } else {
            System.out.println("密码必修为6位");
            return;
        }
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        if (balance <= 20) {
            System.out.println("balance不能低于20");
        }
        else {
            this.balance = balance;
        }

    }
}
```

我们使用Scanner的方法`nextLine()`，如果检测到回车，没有接受到任何信息，那么就为null。

```java
# No01.java
package NewTest;

import objectOriented.Test;
import practice01.Account;

import java.util.Scanner;

public class No01 {
    public static void main(String[] args) {
        Account account = new Account();
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入名字");
        String name = sc.nextLine();
        if (name.isEmpty()) {
            name = null;
        }
        account.setName(name);

        System.out.println("请输入密码");
        String password = sc.nextLine();
        if (password.isEmpty()) {
            password = null;
        }
        account.setPassword(password);

        System.out.println("请输入余额");
        double balance = sc.nextDouble();
        account.setBalance(balance);

        //输出当前获取的名字和密码
        System.out.println(account.getName());
        System.out.println(account.getPassword());
        System.out.println(account.getBalance());
    }
}
```

## 继承

继承主要是用来提高代码的复用性，从而减少重复代码的编写；当我们根据现有的类创建一个新的类的时候，这个类就有了继承的关系。

在继承关系中，现有的类被称为父类（或超类），而新创建的类被称为子类（或派生类）。子类继承了父类的方法和状态，同时还可以添加新的方法和状态或者覆盖（override）父类的方法。

继承只需要在原有的类后面添加以下内容就可以创建子类：

```
子类 extends 父类 {
}
```

当我们使用继承的时候，一般情况下IDEA会出现提示：

![image-20240919151824834](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240919151824834.png)

`Name、age`两个属性从`Person`中进行了继承，我们就不在需要重复写这个属性了，可以直接从`Teacher`类中直接删掉，例如：

![image-20240919151950718](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240919151950718.png)

可以看见，只要通过继承，就不需要重复造轮子，只需要编写继承后的类的单独的属性和方法。

`Person`就是父类，`Teacher`就是子类，儿子继承父亲的一些遗传，所以不需要单独再去编写。

**注意：我们在定义`Person`的时候，没有写`extends`。在Java中，没有明确写`extends`的类，编译器会自动加上`extends Object`。所以，任何类，除了`Object`，都会继承自某个类。**

继承树的关系如下：

```
       ┌───────────┐
       │  Object   │
       └───────────┘
             ▲
             │
       ┌───────────┐
       │  Person   │
       └───────────┘
          ▲     ▲
          │     │
          │     │
┌───────────┐ ┌───────────┐
│  Student  │ │  Teacher  │
└───────────┘ └───────────┘
```

Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有`Object`特殊，它没有父类。

调用`Students、Teacher、Person`三个类，

```java
package NewTest;

import objectOriented.Student;

public class RunCode {
    public static void main(String[] args) {
        //调用父类和子类
        Person person = new Person();
        person.setName("BASIC");
        person.setAge(52);
        System.out.println(person.getName() + " " + person.getAge());

        Teacher teacher = new Teacher();
        teacher.setName("天阁创客");
        teacher.setAge(21);
        teacher.setSex('男');
        System.out.println(teacher.getName() + " " + teacher.getAge() + " " + teacher.getSex());

        Student students = new Student();
        students.setName("xxx");
        students.setSex('男');
        students.setAge(18);
        students.setDeposit(1000);
        System.out.println(students.getName() + " " + students.getAge() + " " +
                students.getSex() + " " + students.getDeposit());

    }
}
```

可以看见，所有的属性都成功被继承到Students和Teacher类上面，并且成功传参。

![image-20240919153814099](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240919153814099.png)

**注意：子类的继承会受到访问修饰符号的影响，但是子类不能访问父类的属性和方法，只能通过公开方法去访问；`protected`关键字可以把字段和方法的访问权限控制在继承树内部，一个`protected`字段和方法可以被其子类，以及子类的子类所访问**

### 父类构造器

创建子类的对象的时候，不管使用的子类是上面构造器，默认情况下都会去调用父类的无参构造器super()。如果父类没有提供无参构造器，就会在子类的构造器中用super去指定使用的是哪一个父类构造器；父类构造器的调用会一直追溯到顶级父类Object。

我们在父类、子类创建构造器：

![image-20240919173902516](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240919173902516.png)

![image-20240919173931255](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240919173931255.png)

![image-20240919173953864](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240919173953864.png)

![image-20240919175014318](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240919175014318.png)

运行含有Main方法的RunCode类，结果如下：

![image-20240919174018458](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240919174018458.png)

当我们在调用类的方法的时候，我们传入参数后，返回的就是有参构造：

![image-20240919174853139](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240919174853139.png)



#### super







#### 练习



































