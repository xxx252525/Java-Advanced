# 类与对象

物以类聚，什么是类？我们知道我们常见的物品都是分类的，根据不同的特征进行分类，把一些相同特征的物品氛围一个类别，在编程中，类也是这个道理。把共有的特点作为物品的属性，这就是类。而包含这写类属性的物品我们叫他对象。

以下这段代码就表示了一个简单的类。

- class是类的关键字，表明这是一个类，class前面会有一个修饰符来表明这个类的使用范围【一般叫也做作用域】，比如public就表示共有的，对大家都可以使用；
- cat表示一个类的名字，也就是猫类；
- {}内的是属性，也就是猫的特点；

```java
# 类
class cat {
    String name;
    int age;
    String color;
}
```

以下的代码表示对象：

- 在代码中我们使用Cat类创建了一个对象实例Cat()，并将其赋值给变量cat；
- 使用cat.name调用Cat类的属性name，并给他赋值，于是有了猫的名字“Tom”；

```java
# 对象

public class class24090901 {

    public static void main(String[] args) {
        //创建对象
        Cat cat = new Cat();
        cat.name = "Tom";
        cat.age = 5;
        cat.color = "white";
        System.out.println(cat.name + " " + cat.age + " " + cat.color);

        Cat cat2 = new Cat();
        cat2.name = "Jerry";
        cat2.age = 6;
        cat2.color = "black";
        System.out.println(cat2.name + " " + cat2.age + " " + cat2.color);

    }
}
```

## 方法的定义和调用

定义方法的格式如下：

```java
修饰符 方法的返回值类型 方法名(形参列表){
    方法主体
    和返回值
}
```

- 调用方法也是非常简单的，当创建实例之后，只需要用实例引用方法即可：

```java
实例.方法()
```

```java
# 方法的定义和调用
import java.time.LocalDate;
import java.util.Scanner;

public class CountAge {
    //创建属性
    public int age;
    public int year;

    //创建方法
    public void count() {
        //接收年龄
        System.out.println("请输入你的年龄");
        Scanner sc = new Scanner(System.in);
        age = sc.nextInt();
        //自动获取当前年份
        LocalDate localDate = LocalDate.now();
        int year = localDate.getYear();
        System.out.println(year);
        //计算出生年份
        int YearOfBirth = year - age;
        System.out.println("出生年份为：" + YearOfBirth);
    }

    public static void main(String[] args) {
        //创建对象
        CountAge countAge = new CountAge();
        //调用方法
        countAge.count();
    }
}

```

## 传递参数

一个方法可以有多个参数，也可以没有参数，多个参数的时候用逗号隔离；参数可以为任意类型；在方法定义的时候的参数叫做形式参数（简称形参），方法实际调用的参数叫做实际参数（简称实参）；实参和形参的类型、数量、顺序必须一致。

在count方法中传递参数，设置传递参数的类型和变量，在调用函数的时候传入对应的类型的值即可，例如：

```java
# 传递参数
import java.util.Scanner;

public class CountAge {
    //创建属性
    public int age;
    public int year;

    //创建方法
    public void count(int year) {
        //接收年龄
        System.out.println("请输入你的年龄");
        Scanner sc = new Scanner(System.in);
        age = sc.nextInt();
        
        //计算出生年份
        int YearOfBirth = year - age;
        System.out.println("出生年份为：" + YearOfBirth);
    }

    public static void main(String[] args) {
        //创建对象
        CountAge countAge = new CountAge();
        //调用方法
        countAge.count(2024);
    }
}
```

这里给定了一个int类型的形参year，我们在调用方法的时候传入形参的值为2024。

### 方法的传参机制

值传递时，传递的是实参的副本，形参的修改不会影响实参

![image-20240911210859705](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240911210859705.png)

---

引用传递时，传递的是实参的引用（地址），形参的修改可能会影响实参

```java
 public class ReferenceTransfer {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        modifyArray(arr);
        System.out.println(arr[0]);  // 输出 10
    }

    public static void modifyArray(int[] array) {
        array[0] = 10;  // 修改数组的第一个元素
    }
}

```

`arr` 是一个引用类型的数组，传递给 `modifyArray()` 时，传递的是数组的引用（地址）。在 `modifyArray()` 函数中，通过这个引用修改了数组的第一个元素，把 `array[0]` 改为 10。因为 `arr` 和 `array` 实际上指向同一个数组，所以修改 `array` 的内容也会影响 `arr`，所以最终在 `main()` 函数中输出的 `arr[0]` 的值为 10。

---

在Java等编程语言中，`String`类型的参数传递有一些特殊之处，`String`在Java中是不可变的（immutable），也就是说，一旦创建了`String`对象，不能更改它的内容。每次对`String`进行修改时，都会生成一个新的`String`对象，而原始的`String`对象保持不变。例如：

```java
public class StringTest {
    public static void main(String[] args) {
        String str = "Hello";
        modifyString(str);
        System.out.println(str);  // 输出还是 "Hello"
    }

    public static void modifyString(String s) {
        s = s + " World";
        System.out.println(s);    // 输出 "Hello World"
    }
}

```

`str` 传递给了 `modifyString()` 方法，实际上传递的是`str`引用的副本。在`modifyString()`方法内部，当执行 `s = s + " World"` 时，实际上创建了一个新的`String`对象 `"Hello World"`，并将`s`的引用指向这个新对象。但是原始的`str`仍然指向最初的 `"Hello"`，因此`main()` 方法中的 `str` 没有受到影响。

---

## 内外部调用

内外部调用就是在类的内部和外部调用的区别，请看代码：

```java
# 内部低调用方法
import java.time.LocalDate;
import java.util.Scanner;

public class CountAge {
    //创建属性
    public int age;
    public int year;

    //创建方法
    public void count(int year) {
        //接收年龄
        System.out.println("请输入你的年龄");
        Scanner sc = new Scanner(System.in);
        age = sc.nextInt();
        
        //计算出生年份
        int YearOfBirth = year - age;
        System.out.println("出生年份为：" + YearOfBirth);
    }

    public static void main(String[] args) {
        //创建对象
        CountAge countAge = new CountAge();
        //调用方法
        countAge.count(2024);
    }
}

```

我们创建好了类为CountAge()，在类的里面定义了属性、方法和Main主体方法；在一个雷总进行方法调用就叫做内部调用，如果不在一个类中，在另外一个A类中调用B类方法和属性，这就叫做外部调用，如下：

```java
# Cat.java

//定义类
public class Cat {
    //定义属性
    String name;
    int age;
    String color;

    //定义方法
    void eat(){
        System.out.println("吃鱼");
    }
    void drink(){
        System.out.println("喝水");
    }
    void sleep(){
        System.out.println("睡觉");
    }

}
```

```java
# CatHabit.java

public class CatHabit {

    public static void main(String[] args) {
        //实例化对象
        Cat cat = new Cat();
        //调用方法
        cat.drink();
        cat.eat();
        cat.sleep();
    }
}
```

可以看见这是两个Java文件，我们在CatHabit这个类中调用了Cat.java文件中的Cat类的方法，从而实现外部调用，外部调用会被方法本身的修饰符限制，在使用的时候请注意。

## 返回值

一个方法只能返回一个值，然后返回多个可用数组，返回值可以是任何类型，但是必须和return的值类型兼容，没有就可以使用viod表示。

```java
# Cat.java

//定义类
public class Cat {
    //定义属性
    String name;
    int age;
    String color;
    
    //返回值
    int[] num(){
        System.out.println("返回值：");
        return new int[] {100,200,300,400,500};
    }

}
```

这里在Cat.java文件中创建了一个方法num用来返回一个数组的信息，然后我们在CatHabit.java调用num的方法并且将其赋值给数组a，然后遍历打印出数组的信息，在`int[] a = cat.num()`中队的数组实际上是这样的`int[] a = {100,200,300,400,500]`，所以当我们遍历打印的，实际上是Cat.java类中num返回的数组。

```java
# CatHabit.java
public class CatHabit {

    public static void main(String[] args) {
        //调用方法
        int[] a = cat.num();
        for (int i : a) {
            System.out.println("array:" + i);
        }
        System.out.println(Arrays.toString(a));
    }
}
```

方法嵌套的时候执行顺序就是代码写的顺序。

当执行方法的时候，会开辟一个独立的栈空间，然后当方法执行完毕后会返回到方法调用的地方，然后继续执行后面的代码，直到执行完毕`main`方法。

<img src="./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240911205034692.png" alt="image-20240911205034692" />

## 静态属性Static

静态属性也叫做类属性，与之对应的还有实例属性，也叫做对象属性。

```java
# CodeEdit.java
public class CodeEdit {
    //实例属性
    String Tools;
    String CodeLanguage;
    //静态属性
    static String CodeEditor;

    //实例方法
    public void StudyCodeLanguage(){
        Scanner str = new Scanner(System.in);
        System.out.println("请输入你学习编程语言");
        CodeLanguage = str.nextLine();
        System.out.println("你学习编程语言是"+CodeLanguage);

    }
    //静态方法
    public static void UseCodeEditor(){
        Scanner str = new Scanner(System.in);
        System.out.println("请输入你使用的编程编辑器");
        CodeEditor = str.nextLine();
        System.out.println("你使用的编程编辑器是"+CodeEditor);
    }

}
```

可以明显看出两者的区别，实例属性和方法必须创建一个实例，然后调用其方法；而静态属性就很方便，可以直接通过类进行方法和属性的调用，不需要像实例属性和方法一样，重复创建实例进行调用。

```java
# Test03.java
public class Test03 {

    public static void main(String[] args) {
        CodeEdit x = new CodeEdit();
        //调用实例属性
        x.Tools = "Minecraft Launcher";
        x.CodeLanguage = "Java";
        //调用实例方法
        x.StudyCodeLanguage();
        //调用静态属性
        CodeEdit.CodeEditor = "IDEA";
        //调用静态方法
        CodeEdit.UseCodeEditor();
    }
}
```

## Java重载

在同一作用域内，允许我们使用同一个方法名来执行不同的操作，比如传递参数的时候不限制类型、数量、顺序等，与返回值无关，只看参数列表，这就是重载，重载是一种多态性表现形式。

例如：

```java
import java.util.Arrays;

public class Test04 {
    //定义方法
    static String test(String str) {
        return str;
    }

    static int test(int a) {
        return a;
    }

    static int[] test(int[] arr) {
        return arr;
    }

    static double test(double d) {
        return d;
    }

    static boolean test(boolean b) {
        return b;
    }

    static float test(float f) {
        return f;
    }

    static char test(char c) {
        return c;
    }

    public static void main(String[] args) {
        //调用方法
        String str = test("Hello");
        int a = test(100);
        int[] arr = test(new int[]{1, 2, 3});
        double d = test(3.14);
        boolean b = test(true);
        float f = test(3.14f);
        char c = test('A');
        System.out.println(str + " " + a + " " + Arrays.toString(arr) + " " + d + " " + b + " " + f + " " + c);
    }
}

```

可以看见，我们在定义test方法的时候使用了不同类型的数据类型进行大量的定义，如果是相同的就会出现错误，然后我们在调用传入参数的时候就可以传入自己定义过的任意类型。

## 可变参数

让方法接受任意参数，这就是可变参数，只需要在参数类型后面添加`...`即可。

可变参数可以当做数组处理、本质上也是一个数组；可变参数的实参可以为数组，数量为任意；注意只能传入一种类型，传入任意数量的时候，不能同时传入多种类型。

例如：

```java
public class Test05 {

    public static void main(String[] args) {
        System.out.println(test(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        System.out.println(test("Hello", "World"));
    }

    //可变参数
    static int test(int... arr) {
        return 0;
    }

    static String test(String... arr) {
        return "";
    }
}
```

可以看见，我们在定义方法的的时候在数据类型后面添加了`...`，当传入大量参数的时候必须是同一个数据类型，如果是不同类型就会报错。

## 构造器

构造器和类名是一样的，没有返回值；当创建对象的时候会自动调用构造器；如果没有构造器就会自动生成一个默认的无参数的构造器。

一个类可以定义多个不同的构造器，也就是构造器的重载；当构造器被定义之后，默认的构造器就被覆盖了。

```java
#Test.java

public class Test {
    String name = null;
    //创建构造器
    Test(){
        System.out.println("Test()");

    }

    Test(String Name){
        System.out.println("Test(String Name)");
    }

    Test(String Name, int num){
        System.out.println("Test(String Name, int num)");
    }
}

```

可以看见我们创建了多个构造器，每个构造器的参数不一样；我们通过创建实例的方式来调用方法，运行之后会就输出构造器的返回结果。

```java
# Test06.java

public class Test06 {

    public static void main(String[] args) {
        Test test = new Test();
        Test test1 = new Test("Hello");
        Test test2 = new Test("Hello",100);

    }

}
```

在创建对象的过程中，加载类的信息只会加载一次、然后在堆里面分配地址，然后完成对象的初始化（从默认初始化到显示初始化，最后到构造器初始化）。

## 变量作用域

### 全局变量

全局变量就是除了在自己的类中调用，还可以在其他的类里面调用，可以添加访问修饰符号，可以不用赋值直接使用，有默认值。

例如：

```java
# Test.java
package objectOriented;

public class Test {
    //全局变量
    public static int count = 0;                //全局静态变量int
    public String name;							//全局变量name

    public void test (){						//公有的方法
        count = 100;
        name = "天阁创客official";
        System.out.println("在当前的Test类中调用变量count和name");
    }
}
```

```java
# Test06.java
package objectOriented;

public class Test06 {

    public static void main(String[] args) {

        //在另外一个类中调用Test的全局变量
        Test test = new Test();
        test.name = "tiangesec.org.cn";
        test.test();
        System.out.println("在Test06类中调用Test的name变量和方法");

    }

}
```

可以看见我们在Test类中和Test06中都调用了Test的属性和方法，这就是全局变量。运行结果如下：

![image-20240916155650230](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916155650230.png)

**注意：全局变量当创建的对象被销毁的时候就会被销毁，被创建的时候也会伴随对象而创建。一般在类中定义的变量没有加特殊的修饰符就可以被全局调用，作用域会受到修饰符号的影响**

### 局部变量

属性在之外的地方无法调用，只能在当前的作用与中调用，只能在对应的代码块中使用。局部变量没有默认值，必须赋值之后才能使用，随着代码的结束就会被销毁，并且不可以加访问修饰符号。

如图：

![image-20240916160631446](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916160631446.png)

![image-20240916160943585](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916160943585.png)

**全局变量与局部变量的对比：**

![image-20240916161246970](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916161246970.png)

### 块级作用域

块级别作用句就是在某个代码块，某个片段中被定义，仅能被当前片段而调用的变量。在全局中有全局块作用域，在局部中有局部作用域，例如：

#### 静态块变量

![image-20240916162952436](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916162952436.png)

#### for循环块变量

想类似与for循环这样类似的块区域类型的语句，创建出的代码块中的变量是只能在当前区域类型的语句块中调用入，如图：

![image-20240916163654443](./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.assets/image-20240916163654443.png)

































